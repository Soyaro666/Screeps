var roleCollection = require('roleCollection');
var taskRespawn = require('task.respawn');

module.exports.loop = function () {
	
	for(var name in Game.rooms) {
        console.log('Room "'+name+'" has '+Game.rooms[name].energyAvailable+' of '+Game.rooms[name].energyCapacityAvailable+' energy');
		
		//gathering existing Creeps
		var localCreeps = Game.rooms[name].find(FIND_MY_CREEPS);
		var attackers = _.filter(localCreeps, (creep) => creep.memory.role == 'attacker');
		var upgraders = _.filter(localCreeps, (creep) => creep.memory.role == 'upgrader');
		var chargers = _.filter(localCreeps, (creep) => creep.memory.role == 'charger');
		var builders = _.filter(localCreeps, (creep) => creep.memory.role == 'builder');
		var localSpawns = Game.rooms[name].find(FIND_MY_SPAWNS);
		var spawn = localSpawns[0].name;
		
		var roomLevel = Game.rooms[name].controller.level;
		for(var builds in Game.rooms[name].structures) {
			/*var maxAttackers = Game.structures[builds].room.find(FIND_MY_STRUCTURES, {
				filter: (structure) => {
					return (structure.structureType == STRUCTURE_EXTENSION ||
							structure.structureType == STRUCTURE_SPAWN ||
							structure.structureType == STRUCTURE_TOWER);
				}
			}).length;*/
			if(Game.structures[name].structureType == STRUCTURE_TOWER) {
				var tower = Game.structures[name];
			}
			if(tower) {
				var closestHostile = tower.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
				var closestDamagedStructure = tower.pos.findClosestByRange(FIND_MY_STRUCTURES, {
					filter: (structure) => structure.hits < structure.hitsMax
				});
				if(closestHostile) {
					tower.attack(closestHostile);
				} else if(closestDamagedStructure) {
					tower.repair(closestDamagedStructure);
				}
				var tower = false;
			}
		}
		console.log('Attackers: '+attackers.length+', Chargers: '+chargers.length+', Upgraders: '+upgraders.length+', Builders: '+builders.length);
		
		var newTask = false;
		if(chargers.length < 1) {
			newTask = 'charger';
		} else if(upgraders.length < 1) {
			newTask = 'upgrader';
		} else if(builders.length < 1) {
			newTask = 'builder';
		} else if(attackers.length < roomLevel) {
			newTask = 'attacker';
		}
		
		if(newTask) {
			taskRespawn.run(newTask, spawn, Game.rooms[name].energyCapacityAvailable);
			newTask = false;
		}
		
		if(Game.spawns[spawn].spawning) { 
			var spawningCreep = Game.creeps[Game.spawns[spawn].spawning.name];
			Game.spawns[spawn].room.visual.text(
				'🛠️' + spawningCreep.memory.role,
				Game.spawns[spawn].pos.x + 1, 
				Game.spawns[spawn].pos.y, 
				{align: 'left', opacity: 0.8});
		}
		
		
		var extenders = Game.rooms[name].find(FIND_MY_STRUCTURES, {
			filter: (structure) => {
				return (structure.structureType == STRUCTURE_EXTENSION);
			}
		});
		var maxExtenders = roomLevel * 5 - 5;
		var towers = Game.rooms[name].find(FIND_MY_STRUCTURES, {
			filter: (structure) => {
				return (structure.structureType == STRUCTURE_TOWER);
			}
		});
		
		var rng1 = Math.random() * 10 - 5;
		var rng2 = Math.random() * 10 - 5;
		
		var terrain = Game.map.getRoomTerrain(Game.spawns[spawn].room.name);
		var constructionSites = Game.spawns[spawn].room.find(FIND_CONSTRUCTION_SITES);
		var buildDelay = 500;

		if(spawn && constructionSites.length < 1) {
			if(!Game.spawns[spawn].memory.lastbuild || Game.spawns[spawn].memory.lastbuild < Game.time) {
				var chargeSource = Game.rooms[name].controller.pos.findClosestByPath(FIND_SOURCES);
				var newStreet = Game.rooms[name].controller.pos.findPathTo(chargeSource, {ignoreCreeps:true});
				var last = newStreet.pop();
				for(var road in newStreet) {
					if(road < newStreet.length) {
						var buildx = newStreet[road].x;
						var buildy = newStreet[road].y;
						if(terrain.get(buildx, buildy) == 0 || terrain.get(buildx, buildy) == 2) {
							if(Game.spawns[spawn].room.createConstructionSite(buildx, buildy, STRUCTURE_ROAD)) {
								Game.spawns[spawn].memory.lastbuild = Game.time + buildDelay;
							}
						}
					}
				}
				
				var sources = Game.spawns[spawn].room.find(FIND_SOURCES);
				for(var i in towers) {
					var newLength = sources.push(towers[i]);
				}
				for(var i in extenders) {
					var newLength = sources.push(extenders[i]);
				}
				var newLength = sources.push(Game.rooms[name].controller);
				
				for(var dest in sources) {
					var newStreet = Game.spawns[spawn].pos.findPathTo(sources[dest], {ignoreCreeps:true});
					var last = newStreet.pop();
					for(var road in newStreet) {
						if(road < newStreet.length) {
							var buildx = newStreet[road].x;
							var buildy = newStreet[road].y;
							if(terrain.get(buildx, buildy) == 0 || terrain.get(buildx, buildy) == 2) {
								if(Game.spawns[spawn].room.createConstructionSite(newStreet[road].x, newStreet[road].y, STRUCTURE_ROAD)) {
									Game.spawns[spawn].memory.lastbuild = Game.time + buildDelay;
								}
							}
						}
					}
					
				}
				
				var newLength = sources.unshift(Game.spawns[spawn]);
				var last = sources.pop();
				
				for(var dest in sources) {
					for(var roadx = 0; roadx < 3; roadx++) {
						for(var roady = 0; roady < 3; roady++) {
							if(!(roadx == 1 && roady == 1)) {
								var buildx = sources[dest].pos.x - 1 + roadx;
								var buildy = sources[dest].pos.y - 1 + roady;
								if(terrain.get(buildx, buildy) == 0 || terrain.get(buildx, buildy) == 2) {
									if(Game.spawns[spawn].room.createConstructionSite(buildx, buildy, STRUCTURE_ROAD)) {
										Game.spawns[spawn].memory.lastbuild = Game.time + buildDelay;
									}
								}
							}
						}
					}
				}
				var sources = Game.spawns[spawn].room.find(FIND_SOURCES);
				for(var dest in sources) {
					for(var roadx = 0; roadx < 5; roadx++) {
						for(var roady = 0; roady < 5; roady++) {
							if(!(roadx == 1 && roady == 1)) {
								var buildx = sources[dest].pos.x - 2 + roadx;
								var buildy = sources[dest].pos.y - 2 + roady;
								if(terrain.get(buildx, buildy) == 0 || terrain.get(buildx, buildy) == 2) {
									if(Game.spawns[spawn].room.createConstructionSite(buildx, buildy, STRUCTURE_ROAD)) {
										Game.spawns[spawn].memory.lastbuild = Game.time + buildDelay;
									}
								}
							}
						}
					}
				}
			}
		}
		if(roomLevel > 1 && extenders.length < maxExtenders && constructionSites.length < 1 && Game.spawns[spawn].memory.lastbuild < Game.time) {
			if(Game.spawns[spawn].room.createConstructionSite(Game.spawns[spawn].pos.x+rng1, Game.spawns[spawn].pos.y+rng2, STRUCTURE_EXTENSION) == 0) {
				Game.spawns[spawn].memory.lastbuild = Game.time + buildDelay;
			}
		}
		var maxTowers = Math.round(roomLevel / 4.5);
		if(towers.length < maxTowers && Game.spawns[spawn].memory.lastbuild < Game.time) {
			var rng1 = rng1 / 2;
			var rng2 = rng2 / 2;
			var buildx = Game.spawns[spawn].pos.x+rng1;
			var buildy = Game.spawns[spawn].pos.y+rng2;
			if(terrain.get(buildx, buildy) == 0 || terrain.get(buildx, buildy) == 2) {
				if(Game.spawns[spawn].room.createConstructionSite(buildx, buildy, STRUCTURE_TOWER) == 0) {
					Game.spawns[spawn].memory.lastbuild = Game.time + buildDelay;
				}
			}
		}
	}
	
	for(var name in Memory.creeps) {
        if(!Game.creeps[name]) {
            delete Memory.creeps[name];
        }
    }

    for(var name in Game.creeps) {
        var creep = Game.creeps[name];
		roleCollection.run(creep);
    }
}